### 4.1.3 树的性质

1. 树中的结点数等于所有结点的度数加 1。
2. 度为 $m$ 的树中第 i 层至多有 $m^{i-1}$ 个结点 $(i \geq 1)$ 。
3. 高度为 $h$ 的 $m$ 叉树至多有 $\dfrac{m^h - 1}{m - 1}$ 个结点。
4. 具有 $n$ 个结点的 $m$ 叉树的最小高度为 $\lceil \log_m(n(m -1 ) + 1) \rceil$ 。



#### 4.2.1.2 几个特殊的二叉树

1. 满二叉树
   - 一个高度为 $h$，并含有 $2^h - 1$ 个结点的二叉树称为满二叉树，即树中的每一层都含有最多的结点。
2. 完全二叉树
   - 设一个高度为 $h$，有 $n$ 个结点的二叉树，当且仅当其每一个结点都与高度为 $h$ 的满二叉树中编号为 $1 \to n$ 的结点一一对应时，称为完全二叉树。
   - 该树特点
     - 叶子结点只可能在层次最大的两层出现。对于最大层次中的叶子结点，都依次排列在该层最左的位置上。
     - **如果有度为 1 的结点，只可能有一个，且该结点只有左孩子而无右孩子。**即 ${N_1} = 0 \quad or \quad 1$ 。
     - **若 $n$ 为奇数，则每个分支结点都有左子女和右子女；**
     - **若 $n$ 为偶数，则编号最大的分支结点（编号为 $\dfrac{n}{2}$）只有左子女，没有右子女，其余分支结点左、右子女都有。** 
   - 针对该树特点参考例题
     - 一棵完全二叉树上有 $1001$ 个结点，其中叶结点的个数是（ $501$ )。
     - 若一棵完全二叉树有 $768$ 个结点，则该二叉树中叶结点的个数是（ $384$ ）。 
3. 二叉排序树
   - 一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：
     - 左子树上的所有结点的关键字均小于根结点的关键字；
     - 右子树上的所有结点的关键字均大于根结点的关键字；
     - 左子树和右子树又各是一课二叉排序树。
4. 平衡二叉树
   -  树上任一结点的左子树和右子树的深度之差不超过 1。



#### 4.2.1.3 二叉树性质

1. 非空二叉树上叶子结点数等于度为 2 的结点数加 1，即 $N_0 = N_2 + 1$ 。
2. 具有 ${N} (N>0)$ 个结点的完全二叉树的高度为 $\lceil \log_2(N+1) \rceil$ 或 $\lfloor \log_2N \rfloor + 1$ 。



#### 4.2.2.2 链式存储结构

二叉树的链式存储结构描述如下：

```c
typedef struct BiTNode{
    ElemType data;				// 数据域	
    struct BiTNode *lchild;		// 左子树指针
    struct BiTNode *rchild;		// 右子树指针
}
```

- 在含有 $n$ 个结点的二叉链表中含有 $n + 1$ 个空链域。
  - 有 $n$ 个结点，就有 $2n$ 个链域 和 $n-1$ 个度，
  - $n - 1$ 个度使用了 $n - 1$ 个链域，
  - 所以剩下 $n + 1$ 个空链域。



#### 4.2.3.2 综合应用题

4. 一棵高度为 $h$ 的满 $m$ 叉树有如下性质：
   - 编号为 $i$ 的结点的第 $1$ 个孩子结点（若存在）的编号是：$(i - 1)*m + 2$ 。
   - 编号为 $i$ 的结点的双亲结点（若存在）的编号是：$\lfloor \dfrac{i-2}{m} \rfloor + 1 \quad (i > 1)$ 。
   - 编号为 $i$ 的结点的第 $k$ 个孩子结点（若存在）的编号是：$(i - 1)*m + k + 1 \quad (1 \leq k \leq m)$ 。



### 4.3.1 二叉树的遍历

4. 借助栈，将二叉树的递归遍历算法转换为非递归遍历算法。
   - 中序遍历的非递归算法

        ```c
        void InOrder(BiTree T){
            InitStack(S);				// 初始化栈
            BiTree p = T;				// p 是遍历指针
            while( p || !IsEmpty(S) ){
                if(p){
                    Push(S, p);
                    p = p->lchild;
                }
                else{
                    Pop(S, p);
                    visit(p);
                    p = p->rchild;
                }
            }
        }
        ```

5. 借助队列，实现二叉树的层次遍历。

   ```c
   void LevelOrder(BiTree T){
       InitQueue(Q);					// 初始化辅助队列
       BiTree p;
       EnQueue(Q, T);					// 将根结点入队
       while( !IsEmpty(Q) ){
           DeQueue(Q, p);				// 队头元素出队
           visit(p);
           if( p->lchild != NULL )
               EnQueue(Q, p->lchild);
           if( p->rchild != NULL )
               EnQueue(Q, p->rchild);
       }
   }
   ```



【王道 P122】（23）

线索二叉树是一种物理结构。

- 二叉树是一种逻辑结构。
- 但线索二叉树是加上线索后的链表结构，是二叉树在计算机内部的一中存储结构。



【王道 P122】（26）

一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是 2。

- 根结点的左子树结点。
- 先序遍历的最后一个元素的右子树结点。



【王道 P122】（31）

后序线索树的遍历仍需要栈的支持。



【王道 P144】

树的遍历操作主要有先根遍历和后根遍历。

- 先根遍历
  - 其访问顺序与这棵树相应二叉树的先序遍历顺序相同。
- 后根遍历
  - 其访问顺序与这棵树相应二叉树的中序遍历顺序相同。



【王道 P145】

森林的遍历操作有先序遍历和中序遍历。

- 先序遍历
  - 访问森林中第一棵树的根结点。
  - 先序遍历第一棵树中根结点的子树森林。
  - 先序遍历除去第一棵树之后剩余的树构成的森林。
- 中序遍历
  - 中序遍历森林中第一棵树的根结点的子树森林。
  - 访问第一棵树的根结点。
  - 中序遍历除去第一棵树之后剩余的树构成的森林。



【王道 P145】

树和森林的遍历与二叉树遍历的对应关系

|    树    |   森林   |  二叉树  |
| :------: | :------: | :------: |
| 先根遍历 | 先序遍历 | 先序遍历 |
| 后根遍历 | 中序遍历 | 中序遍历 |



【王道 P147】（7）

设 F 是一个有 m 个结点的森林，其中有 n 个非终端结点，将 F 变换为二叉树 B 后，B 中右指针域为空的结点有 n + 1 个。

- 根绝森林与二叉树转换规则“左子女右兄弟”，二叉树 B 中右指针为空代表该结点没有兄弟结点。
- 首先，最后一棵树的根结点的右指针为空。
- 每一个非终端结点的最后一个孩子的右指针也为空。



【王道 P147】（9）

将森林 F 转换为对应的二叉树 T 后，F 中叶结点的个数等于 T 中左孩子指针为空的结点个数。




























